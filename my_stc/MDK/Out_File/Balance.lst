C51 COMPILER V9.01   BALANCE                                                               07/03/2020 15:17:28 PAGE 1   


C51 COMPILER V9.01, COMPILATION OF MODULE BALANCE
OBJECT MODULE PLACED IN .\Out_File\Balance.obj
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE ..\CODE\Balance.c LARGE OPTIMIZE(8,SPEED) BROWSE INCDIR(..\..\Libraries\
                    -libraries;..\..\Libraries\seekfree_libraries;..\..\Libraries\seekfree_peripheral;..\USER\inc;..\USER\src;..\CODE) DEBUG 
                    -OBJECTEXTEND PRINT(.\Out_File\Balance.lst) TABS(2) OBJECT(.\Out_File\Balance.obj)

line level    source

   1          /*
   2           * @Description  : 
   3           * @Version      : 
   4           * @Date         : 2020-06-21 20:30:51
   5           * @LastEditTime : 2020-06-24 18:09:29
   6           */
   7          #include "Balance.h"
   8          S_FLOAT_XYZ
   9          GYRO_Real,             // é™€èºä»ªè½¬åŒ–åçš„æ•°æ®
  10              ACC_Real,          // åŠ é€Ÿåº¦è®¡è½¬åŒ–åçš„æ•°æ®
  11              Attitude_Angle,    // å½“å‰è§’åº¦
  12              Last_Angle,        // ä¸Šæ¬¡è§’åº¦
  13              Target_Angle,      // ç›®æ ‡è§’åº¦
  14              Target_Angle_Grow; // ç›®æ ‡è§’åº¦å¢é•¿
  15          S_INT16_XYZ
  16          GYRO,            // é™€èºä»ªåŸå§‹æ•°æ®
  17              GYRO_Offset, // é™€èºä»ªæ¸©é£˜
  18              GYRO_Last,   // é™€èºä»ªä¸Šæ¬¡æ•°æ®
  19              ACC,         // åŠ é€Ÿåº¦è®¡æ•°æ®
  20              ACC_Offset,  // åŠ é€Ÿåº¦è®¡æ¸©é£˜
  21              ACC_Last;    // åŠ é€Ÿåº¦è®¡ä¸Šæ¬¡æ•°æ®
  22          S_INT32_XYZ
  23          Tar_Ang_Vel,          // ç›®æ ‡è§’é€Ÿåº¦
  24              Tar_Ang_Vel_Last, // ä¸Šæ¬¡ç›®æ ‡è§’é€Ÿåº¦
  25              Tar_Ang_Vel_Grow; // ç›®æ ‡è§’é€Ÿåº¦å¢é•¿
  26          int32
  27              In_Out_Roundabout_I = 0,
  28              In_Out_Roundabout_ture_I = 0,
  29              Out_Roundabout_I = 0,
  30              Run_I = 0,
  31              Speed_Now = 0,        // å½“å‰å®é™…é€Ÿåº¦
  32              Speed_Now_Last = 0,   // ä¸Šæ¬¡å®é™…é€Ÿåº¦
  33              Speed_Min = 0,        // å·¦å³æœ€å°é€Ÿåº¦
  34              Speed_Set = 0,        // ç›®æ ‡è®¾å®šé€Ÿåº¦
  35              Theory_Duty = 0,      // ç†è®ºç›´ç«‹å ç©ºæ¯”
  36              Vel_Set = 0,          // ç›®æ ‡è½¬å‘è§’é€Ÿåº¦
  37              Direct_Parameter = 0, // è½¬å‘ç³»æ•°
  38              Direct_Last = 0,
  39              Curvature = 0;            // ç›®æ ‡è½¬å‘åŠå¾„å€’æ•°
  40          float Target_Angle_min = 200, //è·‘åŠ¨å‰å€¾æœ€å¤§è§’åº¦
  41              Target_Angle_max = 800;   //è·‘åŠ¨åä»°æœ€å¤§è§’åº¦
  42          /* å„ç§æ ‡å¿—ä½ï¼Œæ”¾å®šæ—¶å™¨ä¸­è¿›è¡Œæ—¶åºæ§åˆ¶ */
  43          char Speed_Flag, Angle_Flag, Ang_Velocity_Flag, Roundabout_cnt = 0, In_Roundabout_Flag = 0, Out_Roundabout
             -_Flag = 0, DMP_Flag;
  44          /********************* ä¸²çº§å¹³è¡¡æ§åˆ¶ *********************/
  45          // é¢‘ç‡æ§åˆ¶åœ¨å®šæ—¶å™¨ä¸­è®¾ç½®
  46          void Balance_Control(void)
  47          {
  48   1        if (Ang_Velocity_Flag) // ç›´ç«‹è§’é€Ÿåº¦ç¯  2ms
  49   1        {
  50   2          Ang_Velocity_Flag = 0;
  51   2      
  52   2          MPU6050_GetData(&GYRO, &ACC); // è¯»å–é™€èºä»ªæ•°æ®
C51 COMPILER V9.01   BALANCE                                                               07/03/2020 15:17:28 PAGE 2   

  53   2          Data_Filter();                // å¯¹åŸå§‹æ•°æ®æ»‘åŠ¨æ»¤æ³¢
  54   2          if (In_Roundabout_Flag)
  55   2          {
  56   3            In_Out_Roundabout_I += GYRO_Real.Z;
  57   3            In_Out_Roundabout_ture_I = In_Out_Roundabout_I * Angle_coe;
  58   3          }
  59   2          /* è§’é€Ÿåº¦ç¯ä½œä¸ºæœ€å†…ç¯æ§åˆ¶ç›´ç«‹ */
  60   2          Theory_Duty += PID_Increase(&Ang_Vel_PID, Ang_Vel, (int32)(GYRO_Real.Y * 10), (int32)(Tar_Ang_Vel.Y));
             - // è®¡ç®—ç›´ç«‹PWM
  61   2          Theory_Duty = range_protect(Theory_Duty, -950, 950);
  62   2      
  63   2          if (System_OK)
  64   2          {
  65   3            // è·å–å½“å‰é€Ÿåº¦ /* è§’é€Ÿåº¦ç¯ä½œä¸ºæœ€å†…ç¯æ§åˆ¶è½¬å‘ */                 //Speed_Min
  66   3            Direct_Parameter = PID_Realize_D(&Direct_PID, Direct, (int32)(GYRO_Real.Z * 100), Curvature * Speed_
             -Min); // è½¬å‘ç¯å·¦æ­£å³è´Ÿ
  67   3            Direct_Parameter = range_protect(Direct_Parameter, -1200, 1200);
  68   3          }
  69   2      
  70   2          Direct_Last = Direct_Last * 0.2 + Direct_Parameter * 0.8; // æ›´æ–°ä¸Šæ¬¡è§’é€Ÿåº¦ç¯ç»“æœ
  71   2          MOTOR_Duty_Left = Theory_Duty - Direct_Last;              //; // å·¦å³ç”µæœºæ ¹æ®è½¬å‘ç³»æ•°è°ƒæ•´å
             -·®é€Ÿ
  72   2          MOTOR_Duty_Right = Theory_Duty + Direct_Last;             //;
  73   2      
  74   2          if (Run_Flag)
  75   2          {
  76   3            if (Stop_Flag)
  77   3              MOTOR_Control(MOTOR_Duty_Left, MOTOR_Duty_Right); // æ§åˆ¶å·¦å³ç”µæœº
  78   3            else
  79   3            {
  80   4              MOTOR_Control(-300, -300); // åœè½¦ç”µæœºæ§åˆ¶
  81   4              delay_ms(500);
  82   4              MOTOR_Control(0, 0); // åœè½¦ç”µæœºæ§åˆ¶
  83   4              delay_ms(7000);
  84   4              Run_I = 0;
  85   4              Stop_Flag = 1;
  86   4            }
  87   3          }
  88   2          else
  89   2          {
  90   3            MOTOR_Control(0, 0); // åœè½¦ç”µæœºæ§åˆ¶
  91   3          }
  92   2          Get_Attitude();
  93   2        }
  94   1        if (Angle_Flag) // ç›´ç«‹è§’åº¦ç¯ 10ms
  95   1        {
  96   2          Speed_Measure();
  97   2          Angle_Flag = 0;
  98   2          /* è§’åº¦ç¯åŠ åˆ°è§’é€Ÿåº¦ç¯ä¸Šä¸²çº§æ§åˆ¶ */ // ç»“æœä¸ºæ”¾å¤§10å€çš„ç›®æ ‡è§’é€Ÿåº¦
  99   2          Tar_Ang_Vel.Y = PID_Realize(&Angle_PID, Angle, (int32)(Attitude_Angle.Y * 100), (int32)Target_Angle.Y)
             -;
 100   2          Tar_Ang_Vel.Y = range_protect(Tar_Ang_Vel.Y, -1500, 1500); // æ³¨æ„æ­£è´Ÿå·
 101   2        }
 102   1        if (Speed_Flag) // é€Ÿåº¦ç¯     100ms
 103   1        {
 104   2          Speed_Flag = 0;
 105   2          /* é€Ÿåº¦ç¯åŠ åˆ°è§’åº¦ç¯ä¸Šä¸²çº§æ§åˆ¶ */
 106   2          if (Run_I < 10000)
 107   2          {
 108   3            Target_Angle.Y = Target_Angle_min - 1000;
 109   3          }
 110   2          else
C51 COMPILER V9.01   BALANCE                                                               07/03/2020 15:17:28 PAGE 3   

 111   2          {
 112   3            Target_Angle.Y = -PID_Realize(&MOTOR_PID, MOTOR, Speed_Now, Speed_Set);                    // ç»“æœ
             -ä¸ºæ”¾å¤§100å€çš„ç›®æ ‡è§’åº¦
 113   3            Target_Angle.Y += Zero_Angle * 100;                                                        // ç›®æ ‡
             -è§’åº¦å åŠ åœ¨é›¶ç‚¹ä¸Š
 114   3            Target_Angle.Y = range_protect((int32)Target_Angle.Y, Target_Angle_min, Target_Angle_max); // -44 22
 115   3          }
 116   2        }
 117   1      }
 118          /* åˆå§‹åŒ–ç”¨åˆ°çš„ä¸€äº›å˜é‡ */
 119          void Balance_Init(void)
 120          {
 121   1        Attitude_Angle.Y = 0;
 122   1        Target_Angle.Y = 0;
 123   1        Tar_Ang_Vel.Y = 0;
 124   1        Tar_Ang_Vel.Z = 0;
 125   1      }
 126          /******** é™å¹…ä¿æŠ¤ *********/
 127          int32 range_protect(int32 duty, int32 min, int32 max) //é™å¹…ä¿æŠ¤
 128          {
 129   1        if (duty >= max)
 130   1        {
 131   2          return max;
 132   2        }
 133   1        if (duty <= min)
 134   1        {
 135   2          return min;
 136   2        }
 137   1        else
 138   1        {
 139   2          return duty;
 140   2        }
 141   1      }
 142          /******** é™å¹…ä¿æŠ¤2 *********/
 143          int32 range_protect_main(int32 duty, int32 min, int32 max) //é™å¹…ä¿æŠ¤
 144          {
 145   1        if (duty >= max)
 146   1        {
 147   2          return max;
 148   2        }
 149   1        if (duty <= min)
 150   1        {
 151   2          return min;
 152   2        }
 153   1        else
 154   1        {
 155   2          return duty;
 156   2        }
 157   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   1417    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =    211      24
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
