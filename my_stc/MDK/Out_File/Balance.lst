C51 COMPILER V9.01   BALANCE                                                               07/15/2020 14:47:16 PAGE 1   


C51 COMPILER V9.01, COMPILATION OF MODULE BALANCE
OBJECT MODULE PLACED IN .\Out_File\Balance.obj
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE ..\CODE\Balance.c LARGE OPTIMIZE(8,SPEED) BROWSE INCDIR(..\..\Libraries\
                    -libraries;..\..\Libraries\seekfree_libraries;..\..\Libraries\seekfree_peripheral;..\USER\inc;..\USER\src;..\CODE) DEBUG 
                    -OBJECTEXTEND PRINT(.\Out_File\Balance.lst) TABS(2) OBJECT(.\Out_File\Balance.obj)

line level    source

   1          /*
   2           * @Description  : 
   3           * @Version      : 
   4           * @Date         : 2020-06-21 20:30:51
   5           * @LastEditTime : 2020-07-14 19:40:14
   6           */
   7          #include "Balance.h"
   8          S_FLOAT_XYZ
   9              GYRO_Real,             // é™€èºä»ªè½¬åŒ–åçš„æ•°æ®
  10              ACC_Real,          // åŠ é€Ÿåº¦è®¡è½¬åŒ–åçš„æ•°æ®
  11              Attitude_Angle,    // å½“å‰è§’åº¦
  12              Last_Angle,        // ä¸Šæ¬¡è§’åº¦
  13              Target_Angle,      // ç›®æ ‡è§’åº¦
  14              Target_Angle_Grow; // ç›®æ ‡è§’åº¦å¢é•¿
  15          S_INT16_XYZ
  16              GYRO,        // é™€èºä»ªåŸå§‹æ•°æ®
  17              GYRO_Offset, // é™€èºä»ªæ¸©é£˜
  18              GYRO_Last,   // é™€èºä»ªä¸Šæ¬¡æ•°æ®
  19              ACC,         // åŠ é€Ÿåº¦è®¡æ•°æ®
  20              ACC_Offset,  // åŠ é€Ÿåº¦è®¡æ¸©é£˜
  21              ACC_Last;    // åŠ é€Ÿåº¦è®¡ä¸Šæ¬¡æ•°æ®
  22          S_INT32_XYZ
  23              Tar_Ang_Vel,      // ç›®æ ‡è§’é€Ÿåº¦
  24              Tar_Ang_Vel_Last, // ä¸Šæ¬¡ç›®æ ‡è§’é€Ÿåº¦
  25              Tar_Ang_Vel_Grow; // ç›®æ ‡è§’é€Ÿåº¦å¢é•¿
  26          int32
  27              In_Out_Roundabout_I = 0,
  28              In_Out_Roundabout_ture_I = 0,
  29              Out_Roundabout_I = 0,
  30              Run_I = 0,
  31              Speed_Now = 0,        // å½“å‰å®é™…é€Ÿåº¦
  32              Speed_Now_Last = 0,   // ä¸Šæ¬¡å®é™…é€Ÿåº¦
  33              Speed_Min = 0,        // å·¦å³æœ€å°é€Ÿåº¦
  34              Speed_Set = 0,        // ç›®æ ‡è®¾å®šé€Ÿåº¦
  35              Theory_Duty = 0,      // ç†è®ºç›´ç«‹å ç©ºæ¯”
  36              Vel_Set = 0,          // ç›®æ ‡è½¬å‘è§’é€Ÿåº¦
  37              Direct_Parameter = 0, // è½¬å‘ç³»æ•°
  38              Direct_Last = 0,
  39              Curvature = 0;            // ç›®æ ‡è½¬å‘åŠå¾„å€’æ•°
  40          float 
  41              Target_Angle_min = 200,   //è·‘åŠ¨å‰å€¾æœ€å°è§’åº¦
  42              Target_Angle_max = 800;   //è·‘åŠ¨åä»°æœ€å¤§è§’åº¦
  43          /**** å„ç§æ ‡å¿—ä½ï¼Œæ”¾å®šæ—¶å™¨ä¸­è¿›è¡Œæ—¶åºæ§åˆ¶ ****/
  44          char Speed_Flag, Angle_Flag, Ang_Velocity_Flag, Roundabout_cnt = 0, In_Roundabout_Flag = 0, Out_Roundabout
             -_Flag = 0;
  45          /********************* ä¸²çº§å¹³è¡¡æ§åˆ¶ *********************/
  46          // é¢‘ç‡æ§åˆ¶åœ¨å®šæ—¶å™¨ä¸­è®¾ç½®
  47          void Balance_Control(void)
  48          {
  49   1        if (Ang_Velocity_Flag) // ç›´ç«‹è§’é€Ÿåº¦ç¯  2ms
  50   1        {
  51   2          Ang_Velocity_Flag = 0;
  52   2      
C51 COMPILER V9.01   BALANCE                                                               07/15/2020 14:47:16 PAGE 2   

  53   2          MPU6050_GetData(&GYRO, &ACC); // è¯»å–é™€èºä»ªæ•°æ®
  54   2          Data_Filter();
  55   2          if (In_Roundabout_Flag)       // åœ†ç¯æ§åˆ¶
  56   2          {
  57   3            In_Out_Roundabout_I += GYRO_Real.Z;
  58   3            In_Out_Roundabout_ture_I = In_Out_Roundabout_I * Angle_coe;
  59   3          }
  60   2          /* è§’é€Ÿåº¦ç¯ä½œä¸ºæœ€å†…ç¯æ§åˆ¶ç›´ç«‹ */  //å¢é‡å¼PID æ‰€ä»¥ ç”¨  +=
  61   2          Theory_Duty += PID_Increase(&Ang_Vel_PID, Ang_Vel, (int32)(GYRO_Real.Y * 10), (int32)(Tar_Ang_Vel.Y));
             - // è®¡ç®—ç›´ç«‹PWM
  62   2          Theory_Duty = range_protect(Theory_Duty, -950, 950);
  63   2      
  64   2          if (System_OK)
  65   2          {
  66   3            // è·å–å½“å‰é€Ÿåº¦  è§’åº¦ç¯ä½œä¸ºæœ€å†…ç¯æ§åˆ¶è½¬å‘   Speed_Min
  67   3            Direct_Parameter = PID_Realize_D(&Direct_PID, Direct, (int32)(GYRO_Real.Z * 100), Curvature * Speed_
             -Min); 
  68   3            Direct_Parameter = range_protect(Direct_Parameter, -1200, 1200);
  69   3          }
  70   2      
  71   2          Direct_Last = Direct_Last * 0.2 + Direct_Parameter * 0.8; // æ›´æ–°ä¸Šæ¬¡è§’é€Ÿåº¦ç¯ç»“æœ
  72   2          MOTOR_Duty_Left = Theory_Duty - Direct_Last;              // å·¦å³ç”µæœºæ ¹æ®è½¬å‘ç³»æ•°è°ƒæ•´å·®é€
             -Ÿ
  73   2          MOTOR_Duty_Right = Theory_Duty + Direct_Last;             
  74   2      
  75   2          if (Run_Flag)   // Run_Flag=1 å¼€è·‘
  76   2          {
  77   3            if (Stop_Flag)   // Stop_Flag=1 æ­£å¸¸ç”µæœºæ§åˆ¶
  78   3              MOTOR_Control(MOTOR_Duty_Left, MOTOR_Duty_Right); // æ§åˆ¶å·¦å³ç”µæœº
  79   3            else
  80   3            {
  81   4              MOTOR_Control(-300, -300); // åœè½¦ç”µæœºæ§åˆ¶
  82   4              delay_ms(500);
  83   4              MOTOR_Control(0, 0); // åœè½¦ç”µæœºæ§åˆ¶
  84   4              delay_ms(7000);
  85   4              Run_I = 0;
  86   4              Stop_Flag = 1;
  87   4            }
  88   3          }
  89   2          else           // Run_Flag=0  åœæ­¢
  90   2          {
  91   3            MOTOR_Control(0, 0); // å…³ç”µæœºæ§åˆ¶
  92   3          }
  93   2          Another_Get_Attitude();
  94   2        }
  95   1        if (Angle_Flag) // ç›´ç«‹è§’åº¦ç¯ 10ms
  96   1        {
  97   2          Speed_Measure();
  98   2          Angle_Flag = 0;
  99   2          /* è§’åº¦ç¯åŠ åˆ°è§’é€Ÿåº¦ç¯ä¸Šä¸²çº§æ§åˆ¶ */ // ç»“æœä¸ºæ”¾å¤§10å€çš„ç›®æ ‡è§’é€Ÿåº¦
 100   2          Tar_Ang_Vel.Y = PID_Realize(&Angle_PID, Angle, (int32)(Attitude_Angle.Y * 100), (int32)Target_Angle.Y)
             -;
 101   2          Tar_Ang_Vel.Y = range_protect(Tar_Ang_Vel.Y, -1500, 1500); // æ³¨æ„æ­£è´Ÿå·
 102   2        }
 103   1        if (Speed_Flag) // é€Ÿåº¦ç¯     100ms
 104   1        {
 105   2          Speed_Flag = 0;
 106   2          /* é€Ÿåº¦ç¯åŠ åˆ°è§’åº¦ç¯ä¸Šä¸²çº§æ§åˆ¶ */  // ç»“æœä¸ºç›®æ ‡è§’åº¦ï¼Œè§’åº¦ç¯ä¸ºå†…ç¯
 107   2          if (Run_I < 10000)
 108   2          {
 109   3            Target_Angle.Y = Target_Angle_min - 1000;
 110   3          }  //ä»¥ä¸‹PIDè´Ÿå· åŸå› æ˜¯é€Ÿåº¦ç¦»æœŸæœ›åå·®å¤§çš„è¿‡ç¨‹ä¸­è§’åº¦ï¼ˆå‰è¿›æ–¹å‘ï¼‰å˜å°ï¼Œå‡
C51 COMPILER V9.01   BALANCE                                                               07/15/2020 14:47:16 PAGE 3   

             -è®¾è§’åº¦ä¸º50ï¼Œç°åœ¨å˜ä¸º40ï¼Œ
 111   2          else//                                                         ï¼ˆPIDæ§åˆ¶å™¨çŸ¥é“é€Ÿåº¦å˜å¤§ï¼Œé‚£
             -ä¹ˆç°åœ¨å°±è¦å‡å°‘ï¼Œå¾—åˆ°ä¸€ä¸ªè´Ÿçš„è¾“å‡ºå€¼ï¼‰
 112   2          {  // ç»“æœä¸ºæ”¾å¤§100å€çš„ç›®æ ‡è§’åº¦                                  é‚£ä¹ˆè§’åº¦è¯¯å·®æ˜¯point
             --nowdataåº”è¯¥ä¸ºè´Ÿï¼Œpointåº”è¯¥ä¸ºè€Œè¾“å‡ºç›®æ ‡è§’åº¦è¦ä¸ºæ­£å· ï¼Œæ‰€ä»¥åŠ è´Ÿå·
 113   3            Target_Angle.Y = -PID_Realize(&MOTOR_PID, MOTOR, Speed_Now, Speed_Set);                
 114   3            Target_Angle.Y += Zero_Angle * 100;    //ç»“æœå åŠ åœ¨é›¶ç‚¹ä¸Š                                   
             -              
 115   3            Target_Angle.Y = range_protect((int32)Target_Angle.Y, Target_Angle_min, Target_Angle_max); 
 116   3          }
 117   2        }
 118   1      }
 119          /* åˆå§‹åŒ–ç”¨åˆ°çš„ä¸€äº›å˜é‡ */
 120          void Balance_Init(void)
 121          {
 122   1        Attitude_Angle.Y = 0;
 123   1        Target_Angle.Y = 0;
 124   1        Tar_Ang_Vel.Y = 0;
 125   1        Tar_Ang_Vel.Z = 0;
 126   1      }
 127          /******** é™å¹…ä¿æŠ¤ *********/
 128          int32 range_protect(int32 duty, int32 min, int32 max) //é™å¹…ä¿æŠ¤
 129          {
 130   1        if (duty >= max)
 131   1        {
 132   2          return max;
 133   2        }
 134   1        if (duty <= min)
 135   1        {
 136   2          return min;
 137   2        }
 138   1        else
 139   1        {
 140   2          return duty;
 141   2        }
 142   1      }
 143          /******** é™å¹…ä¿æŠ¤2 *********/
 144          int32 range_protect_main(int32 duty, int32 min, int32 max) //é™å¹…ä¿æŠ¤
 145          {
 146   1        if (duty >= max)
 147   1        {
 148   2          return max;
 149   2        }
 150   1        if (duty <= min)
 151   1        {
 152   2          return min;
 153   2        }
 154   1        else
 155   1        {
 156   2          return duty;
 157   2        }
 158   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   1417    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =    210      24
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
C51 COMPILER V9.01   BALANCE                                                               07/15/2020 14:47:16 PAGE 4   

END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
