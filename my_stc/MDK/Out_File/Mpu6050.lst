C51 COMPILER V9.01   MPU6050                                                               07/03/2020 15:17:28 PAGE 1   


C51 COMPILER V9.01, COMPILATION OF MODULE MPU6050
OBJECT MODULE PLACED IN .\Out_File\Mpu6050.obj
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE ..\CODE\Mpu6050.c LARGE OPTIMIZE(8,SPEED) BROWSE INCDIR(..\..\Libraries\
                    -libraries;..\..\Libraries\seekfree_libraries;..\..\Libraries\seekfree_peripheral;..\USER\inc;..\USER\src;..\CODE) DEBUG 
                    -OBJECTEXTEND PRINT(.\Out_File\Mpu6050.lst) TABS(2) OBJECT(.\Out_File\Mpu6050.obj)

line level    source

   1          /*
   2           * @Description  : 
   3           * @Version      : 
   4           * @Date         : 2020-06-18 16:23:44
   5           * @LastEditTime : 2020-06-27 22:30:17
   6           */
   7          #include "Mpu6050.h"
   8          
   9          char Offset_OK = 0;
  10          
  11          /*
  12           * å‡½æ•°åï¼šMPU6050_Init
  13           * æè¿°  ï¼šé™€èºä»ªåˆå§‹åŒ–
  14           * è¾“å…¥  ï¼šæ— 
  15           * è¾“å‡º  ï¼š0æˆåŠŸ  1å¤±è´¥
  16           * è°ƒç”¨  ï¼šå¤–éƒ¨è°ƒç”¨
  17           */
  18          uchar My_MPU6050_Init(void)
  19          {
  20   1        uchar res;
  21   1        MPU6050_WR(MPU_PWR_MGMT1_REG, 0X80); // å¤ä½MPU6050
  22   1        delay_ms(10);
  23   1        MPU6050_WR(MPU_PWR_MGMT1_REG, 0X00); // å”¤é†’MPU6050
  24   1        delay_ms(10);
  25   1        MPU6050_WR(MPU_PWR_MGMT1_REG, 0X01); // è®¾ç½®CLKSEL,PLL Xè½´ä¸ºå‚è€ƒ
  26   1        delay_ms(10);
  27   1        MPU6050_WR(MPU_GYRO_CFG_REG, 3 << 3); // é™€èºä»ªä¼ æ„Ÿå™¨,Â±2000dps // 0,Â±250dps;1,Â±500dps;2,Â±1000dp
             -s;3,Â±2000dps
  28   1        delay_ms(10);
  29   1        MPU6050_WR(MPU_ACCEL_CFG_REG, 0 << 3); // åŠ é€Ÿåº¦ä¼ æ„Ÿå™¨,Â±2g   // 0,Â±2g;1,Â±4g;2,Â±8g;3,Â±16g
  30   1        delay_ms(10);
  31   1        MPU6050_WR(MPU_SAMPLE_RATE_REG, 0X00); // è®¾ç½®MPU6050çš„é‡‡æ ·ç‡,1KHz
  32   1        delay_ms(10);
  33   1        MPU6050_WR(MPU_CFG_REG, 0X01); // è®¾ç½®æ•°å­—ä½é€šæ»¤æ³¢å™¨,188Hz
  34   1        delay_ms(100);
  35   1      
  36   1        res = MPU6050_RD(MPU_DEVICE_ID_REG);
  37   1        if (res == MPU6050_ADRESS) // å™¨ä»¶IDæ­£ç¡®
  38   1        {
  39   2          MPU6050_Offset();
  40   2          Balance_Init();
  41   2          return 0;
  42   2        }
  43   1        else
  44   1        {
  45   2          return 1;
  46   2        }
  47   1      }
  48          
  49          /*
  50           * å‡½æ•°åï¼šMPU6050_Offset
  51           * æè¿°  ï¼šä¼ æ„Ÿå™¨é‡‡é›†é›¶å
  52           * è¾“å…¥  ï¼šæ— 
C51 COMPILER V9.01   MPU6050                                                               07/03/2020 15:17:28 PAGE 2   

  53           * è¾“å‡º  ï¼šæ— 
  54           * è°ƒç”¨  ï¼šå†…éƒ¨è°ƒç”¨
  55           */
  56          void MPU6050_Offset(void)
  57          {
  58   1        uint8 i, Count = 100;
  59   1        int32 temp[6] = {0};
  60   1      
  61   1        GYRO_Offset.X = 0;
  62   1        GYRO_Offset.Y = 0;
  63   1        GYRO_Offset.Z = 0;
  64   1      
  65   1        for (i = 0; i < Count; i++)
  66   1        {
  67   2          MPU6050_GetData(&GYRO, &ACC); // è¯»å–é™€èºä»ªæ•°æ®
  68   2          delay_ms(2);
  69   2      
  70   2          temp[0] += ACC.X;
  71   2          temp[1] += ACC.Y;
  72   2          temp[2] += ACC.Z;
  73   2      
  74   2          temp[3] += GYRO.X;
  75   2          temp[4] += GYRO.Y;
  76   2          temp[5] += GYRO.Z;
  77   2        }
  78   1        ACC_Offset.X = temp[0] / Count;
  79   1        ACC_Offset.Y = temp[1] / Count;
  80   1        ACC_Offset.Z = temp[2] / Count;
  81   1      
  82   1        GYRO_Offset.X = temp[3] / Count;
  83   1        GYRO_Offset.Y = temp[4] / Count;
  84   1        GYRO_Offset.Z = temp[5] / Count;
  85   1      
  86   1        Offset_OK = 1;
  87   1      }
  88          
  89          /*
  90           * å‡½æ•°åï¼šMPU6050_GetData
  91           * æè¿°  ï¼šè·å¾—ä¼ æ„Ÿå™¨æ‰€æœ‰æ•°æ®
  92           * è¾“å…¥  ï¼š*GYRO é™€èºä»ª   *ACC åŠ é€Ÿåº¦è®¡
  93           * è¾“å‡º  ï¼šæ— 
  94           * è°ƒç”¨  ï¼šå¤–éƒ¨è°ƒç”¨
  95           */
  96          void MPU6050_GetData(S_INT16_XYZ *GYRO, S_INT16_XYZ *ACC)
  97          {
  98   1        if (Offset_OK)
  99   1        {
 100   2          ACC->X = GetData(MPU_ACCEL_XOUTH_REG); // è·å–åŠ é€Ÿåº¦è®¡åŸå§‹æ•°æ®
 101   2          ACC->Y = GetData(MPU_ACCEL_YOUTH_REG);
 102   2          ACC->Z = GetData(MPU_ACCEL_ZOUTH_REG);
 103   2      
 104   2          GYRO->X = GetData(MPU_GYRO_XOUTH_REG) - GYRO_Offset.X; // è·å–é™€èºä»ªåŸå§‹æ•°æ®
 105   2          GYRO->Y = GetData(MPU_GYRO_YOUTH_REG) - GYRO_Offset.Y;
 106   2          GYRO->Z = GetData(MPU_GYRO_ZOUTH_REG) - GYRO_Offset.Z;
 107   2        }
 108   1        else
 109   1        {
 110   2          ACC->X = GetData(MPU_ACCEL_XOUTH_REG); // è·å–åŠ é€Ÿåº¦è®¡åŸå§‹æ•°æ®å¹¶å½’ä¸€åŒ–
 111   2          ACC->Y = GetData(MPU_ACCEL_YOUTH_REG);
 112   2          ACC->Z = GetData(MPU_ACCEL_ZOUTH_REG);
 113   2      
 114   2          GYRO->X = GetData(MPU_GYRO_XOUTH_REG); // è·å–é™€èºä»ªåŸå§‹æ•°æ®å¹¶å½’ä¸€åŒ–
C51 COMPILER V9.01   MPU6050                                                               07/03/2020 15:17:28 PAGE 3   

 115   2          GYRO->Y = GetData(MPU_GYRO_YOUTH_REG);
 116   2          GYRO->Z = GetData(MPU_GYRO_ZOUTH_REG);
 117   2        }
 118   1      }
 119          
 120          /*
 121           * å‡½æ•°åï¼šGetData
 122           * æè¿°  ï¼šè·å¾—16ä½æ•°æ®
 123           * è¾“å…¥  ï¼šREG_Address å¯„å­˜å™¨åœ°å€
 124           * è¾“å‡º  ï¼šè¿”å›å¯„å­˜å™¨æ•°æ®
 125           * è°ƒç”¨  ï¼šå¤–éƒ¨è°ƒç”¨
 126           */
 127          int16 GetData(uchar reg)
 128          {
 129   1        uchar H, L;
 130   1      
 131   1        H = MPU6050_RD(reg);
 132   1        L = MPU6050_RD(reg + 1);
 133   1      
 134   1        return ((H << 8) | L); //åˆæˆæ•°æ®
 135   1      }
 136          
 137          #define AcceRatio 16384.0f
 138          #define GyroRatio 16.4f
 139          #define Gyro_Gr 0.0010653                                // è§’é€Ÿåº¦å˜æˆå¼§åº¦ æ­¤å‚æ•°å¯¹åº”é™€èº2000åº¦æ¯ç§’
 140          #define ACC_FILTER_NUM 5                                 // åŠ é€Ÿåº¦è®¡æ»¤æ³¢æ·±åº¦
 141          #define GYRO_FILTER_NUM 1                                // é™€èºä»ªæ»¤æ³¢æ·±åº¦
 142          int32 ACC_X_BUF[ACC_FILTER_NUM], ACC_Y_BUF[ACC_FILTER_NUM], ACC_Z_BUF[ACC_FILTER_NUM]; // æ»¤æ³¢ç¼“å­˜æ•°ç
             -»„
 143          int32 GYRO_X_BUF[GYRO_FILTER_NUM], GYRO_Y_BUF[GYRO_FILTER_NUM], GYRO_Z_BUF[GYRO_FILTER_NUM];
 144          /*
 145           * å‡½æ•°åï¼šData_Filter
 146           * æè¿°  ï¼šæ•°æ®æ»‘åŠ¨æ»¤æ³¢
 147           * è¾“å…¥  ï¼šæ— 
 148           * è¾“å‡º  ï¼šæ— 
 149           * è°ƒç”¨  ï¼šå¤–éƒ¨è°ƒç”¨
 150           */
 151          void Data_Filter(void) // æ•°æ®æ»¤æ³¢
 152          {
 153   1        uchar i;
 154   1        //float ACC_Angle;
 155   1        int32 temp1 = 0, temp2 = 0, temp3 = 0, temp4 = 0, temp5 = 0, temp6 = 0;
 156   1      
 157   1        ACC_X_BUF[0] = ACC.X; // æ›´æ–°æ»‘åŠ¨çª—å£æ•°ç»„
 158   1        ACC_Y_BUF[0] = ACC.Y;
 159   1        ACC_Z_BUF[0] = ACC.Z;
 160   1        GYRO_X_BUF[0] = GYRO.X;
 161   1        GYRO_Y_BUF[0] = GYRO.Y;
 162   1        GYRO_Z_BUF[0] = GYRO.Z;
 163   1      
 164   1        for (i = 0; i < ACC_FILTER_NUM; i++)
 165   1        {
 166   2          temp1 += ACC_X_BUF[i];
 167   2          temp2 += ACC_Y_BUF[i];
 168   2          temp3 += ACC_Z_BUF[i];
 169   2        }
 170   1        for (i = 0; i < GYRO_FILTER_NUM; i++)
 171   1        {
 172   2          temp4 += GYRO_X_BUF[i];
 173   2          temp5 += GYRO_Y_BUF[i];
 174   2          temp6 += GYRO_Z_BUF[i];
 175   2        }
C51 COMPILER V9.01   MPU6050                                                               07/03/2020 15:17:28 PAGE 4   

 176   1      
 177   1        ACC_Real.X = temp1 / ACC_FILTER_NUM / AcceRatio;
 178   1        ACC_Real.Y = temp2 / ACC_FILTER_NUM / AcceRatio;
 179   1        ACC_Real.Z = temp3 / ACC_FILTER_NUM / AcceRatio;
 180   1        GYRO_Real.X = temp4 / GYRO_FILTER_NUM / GyroRatio;
 181   1        GYRO_Real.Y = temp5 / GYRO_FILTER_NUM / GyroRatio;
 182   1        GYRO_Real.Z = temp6 / GYRO_FILTER_NUM / GyroRatio;
 183   1      
 184   1        for (i = 0; i < ACC_FILTER_NUM - 1; i++)
 185   1        {
 186   2          ACC_X_BUF[ACC_FILTER_NUM - 1 - i] = ACC_X_BUF[ACC_FILTER_NUM - 2 - i];
 187   2          ACC_Y_BUF[ACC_FILTER_NUM - 1 - i] = ACC_Y_BUF[ACC_FILTER_NUM - 2 - i];
 188   2          ACC_Z_BUF[ACC_FILTER_NUM - 1 - i] = ACC_Z_BUF[ACC_FILTER_NUM - 2 - i];
 189   2        }
 190   1        for (i = 0; i < GYRO_FILTER_NUM - 1; i++)
 191   1        {
 192   2          GYRO_X_BUF[GYRO_FILTER_NUM - 1 - i] = GYRO_X_BUF[GYRO_FILTER_NUM - 2 - i];
 193   2          GYRO_Y_BUF[GYRO_FILTER_NUM - 1 - i] = GYRO_Y_BUF[GYRO_FILTER_NUM - 2 - i];
 194   2          GYRO_Z_BUF[GYRO_FILTER_NUM - 1 - i] = GYRO_Z_BUF[GYRO_FILTER_NUM - 2 - i];
 195   2        }
 196   1      }
 197          
 198          /*
 199          //éçŸ©é˜µå¡å°”æ›¼æ»¤æ³¢ï¼Œè¿™äº›å‚æ•°ä¸ç”¨æ”¹
 200          #define Peried 1/500.0f   //å¡å°”æ›¼ç§¯åˆ†å‘¨æœŸ
 201          #define Q 2.0f        //è¿‡ç¨‹å™ªå£°2.0   è¶Šå°ç§¯åˆ†è¶Šæ…¢ï¼Œè·Ÿè¸ªåŠ é€Ÿåº¦è®¡è¶Šæ…¢è¶Šå¹³æ»‘
 202          #define R 5000.0f     //æµ‹é‡å™ªå£°5000.0  è¶Šå°è·Ÿè¸ªåŠ é€Ÿåº¦è®¡è¶Šå¿«
 203          float KalmanGain = 1.0f;  //å¡å°”æ›¼å¢ç›Š
 204          
 205          void KalmanFilter(float ACC_Angle)
 206          {
 207            //å¡å°”æ›¼æ»¤æ³¢å±€éƒ¨å‚é‡
 208              static float Priori_Estimation = 0;//å…ˆéªŒä¼°è®¡
 209              static float Posterior_Estimation = 0;//åéªŒä¼°è®¡
 210              static float Priori_Convariance = 0;//å…ˆéªŒæ–¹å·®
 211              static float Posterior_Convariance = 0;//åéªŒæ–¹å·®
 212              
 213            //å¡å°”æ›¼æ»¤æ³¢
 214              //1.æ—¶é—´æ›´æ–°(é¢„æµ‹) : X(k|k-1) = A(k,k-1)*X(k-1|k-1) + B(k)*u(k) 
 215              Priori_Estimation = Posterior_Estimation - GYRO_Real.Y*Peried;    //å…ˆéªŒä¼°è®¡ï¼Œç§¯åˆ†è·å¾—è§’åº¦
 216            if (Priori_Estimation != Priori_Estimation)
 217            {
 218              Priori_Estimation = 0;
 219            }
 220            
 221              //2.æ›´æ–°å…ˆéªŒåæ–¹å·®  : P(k|k-1) = A(k,k-1)*P(k-1|k-1)*A(k,k-1)'+Q(k) 
 222              Priori_Convariance = (float)sqrt( Posterior_Convariance * Posterior_Convariance + Q * Q );
 223            if (Priori_Convariance != Priori_Convariance)
 224            {
 225              Priori_Convariance = 0;
 226            }
 227            
 228              //  å¡å°”æ›¼åéªŒä¼°è®¡ï¼šæµ‹é‡æ›´æ–°  
 229              // 1.è®¡ç®—å¡å°”æ›¼å¢ç›Š  : K(k) = P(k|k-1)*H(k)' / (H(k)*P(k|k-1)*H(k)' + R(k)) /
 230              KalmanGain = (float)sqrt( Priori_Convariance * Priori_Convariance / ( Priori_Convariance * Priori_Conv
             -ariance + R * R ) );
 231            if (KalmanGain != KalmanGain)
 232            {
 233              KalmanGain = 1;
 234            }
 235            
 236              //2.æµ‹é‡æ›´æ–°(æ ¡æ­£): X(k|k) = X(k|k-1)+K(k)*(Z(k)-H(k)*X(k|k-1)) 
C51 COMPILER V9.01   MPU6050                                                               07/03/2020 15:17:28 PAGE 5   

 237              Posterior_Estimation  = Priori_Estimation + KalmanGain * (ACC_Angle - Priori_Estimation );
 238            if (Posterior_Estimation != Posterior_Estimation)
 239            {
 240              Posterior_Estimation = 0;
 241            }
 242            
 243              // 3.æ›´æ–°åéªŒåæ–¹å·®  : P(k|k) =ï¼ˆI-K(k)*H(k)ï¼‰*P(k|k-1) 
 244              Posterior_Convariance = (float)sqrt(( 1 - KalmanGain ) * Priori_Convariance * Priori_Convariance );
 245            if (Posterior_Convariance != Posterior_Convariance)
 246            {
 247              Posterior_Convariance = 0;
 248            }
 249            
 250              //å¾—åˆ°æœ€ç»ˆè§’åº¦ 
 251              Attitude_Angle.Y = Posterior_Estimation;
 252            
 253            if (Attitude_Angle.Y != Attitude_Angle.Y)
 254            {
 255              Attitude_Angle.Y = 1;
 256            }
 257          }
 258          */
 259          /*
 260           * å‡½æ•°åï¼šGet_Attitude
 261           * æè¿°  ï¼šå§¿æ€è§£ç®—
 262           * è¾“å…¥  ï¼šæ— 
 263           * è¾“å‡º  ï¼šæ— 
 264           * è°ƒç”¨  ï¼šå¤–éƒ¨è°ƒç”¨
 265           */
 266          void Get_Attitude(void) // å§¿æ€è§£ç®—
 267          {
 268   1        IMUupdate(GYRO_Real.X * Gyro_Gr * GyroRatio,
 269   1              GYRO_Real.Y * Gyro_Gr * GyroRatio,
 270   1              GYRO_Real.Z * Gyro_Gr * GyroRatio,
 271   1              ACC_Real.X * AcceRatio,
 272   1              ACC_Real.Y * AcceRatio,
 273   1              ACC_Real.Z * AcceRatio); // å§¿æ€è§£ç®—å‡ºæ¬§æ‹‰è§’
 274   1      }
 275          
 276          //===============================å››å…ƒç´ ============================================
 277          #define Kp 1.6f              //10.0f              // proportional gain governs rate of convergence to accelerom
             -eter/magnetometer
 278          #define Ki 0.001f            //1.2f // //0.008f   // integral gain governs rate of convergence of gyroscope bi
             -ases
 279          #define halfT 0.005f           // half the sample periodé‡‡æ ·å‘¨æœŸçš„ä¸€åŠ
 280          float q0 = 1, q1 = 0, q2 = 0, q3 = 0;  // quaternion elements representing the estimated orientation
 281          float exInt = 0, eyInt = 0, ezInt = 0; // scaled integral error
 282          /*
 283           * å‡½æ•°åï¼šIMUupdate
 284           * æè¿°  ï¼šå››å…ƒç´ è§£ç®—æ¬§æ‹‰è§’
 285           * è¾“å…¥  ï¼šé™€èºä»ª åŠ é€Ÿåº¦è®¡
 286           * è¾“å‡º  ï¼šæ— 
 287           * è°ƒç”¨  ï¼šå†…éƒ¨è°ƒç”¨
 288           */
 289          void IMUupdate(float gx, float gy, float gz, float ax, float ay, float az)
 290          {
 291   1        float norm;
 292   1        float vx, vy, vz;
 293   1        float ex, ey, ez;
 294   1      
 295   1        // å…ˆæŠŠè¿™äº›ç”¨å¾—åˆ°çš„å€¼ç®—å¥½
 296   1        float q0q0 = q0 * q0;
C51 COMPILER V9.01   MPU6050                                                               07/03/2020 15:17:28 PAGE 6   

 297   1        float q0q1 = q0 * q1;
 298   1        float q0q2 = q0 * q2;
 299   1        float q1q1 = q1 * q1;
 300   1        float q1q3 = q1 * q3;
 301   1        float q2q2 = q2 * q2;
 302   1        float q2q3 = q2 * q3;
 303   1        float q3q3 = q3 * q3;
 304   1      
 305   1        if (ax * ay * az == 0)
 306   1        {
 307   2          return;
 308   2        }
 309   1      
 310   1        norm = sqrt(ax * ax + ay * ay + az * az); // accæ•°æ®å½’ä¸€åŒ–
 311   1        ax = ax / norm;
 312   1        ay = ay / norm;
 313   1        az = az / norm;
 314   1      
 315   1        // estimated direction of gravity and flux (v and w)  ä¼°è®¡é‡åŠ›æ–¹å‘å’Œæµé‡/å˜è¿
 316   1        vx = 2 * (q1q3 - q0q2); // å››å…ƒç´ ä¸­xyzçš„è¡¨ç¤º
 317   1        vy = 2 * (q0q1 + q2q3);
 318   1        vz = q0q0 - q1q1 - q2q2 + q3q3;
 319   1      
 320   1        // error is sum of cross product between reference direction of fields and direction measured by sensors
 321   1        ex = (ay * vz - az * vy); // å‘é‡å¤–ç§¯åœ¨ç›¸å‡å¾—åˆ°å·®åˆ†å°±æ˜¯è¯¯å·®
 322   1        ey = (az * vx - ax * vz);
 323   1        ez = (ax * vy - ay * vx);
 324   1      
 325   1        exInt = exInt + ex * Ki; // å¯¹è¯¯å·®è¿›è¡Œç§¯åˆ†
 326   1        eyInt = eyInt + ey * Ki;
 327   1        ezInt = ezInt + ez * Ki;
 328   1      
 329   1        // adjusted gyroscope measurements
 330   1        gx = gx + Kp * ex + exInt; // å°†è¯¯å·®PIåè¡¥å¿åˆ°é™€èºä»ªï¼Œå³è¡¥å¿é›¶ç‚¹æ¼‚ç§»
 331   1        gy = gy + Kp * ey + eyInt;
 332   1        gz = gz + Kp * ez + ezInt; // è¿™é‡Œçš„gzç”±äºæ²¡æœ‰è§‚æµ‹è€…è¿›è¡ŒçŸ«æ­£ä¼šäº§ç”Ÿæ¼‚ç§»ï¼Œè¡¨ç°å‡ºæ¥ç
             -š„å°±æ˜¯ç§¯åˆ†è‡ªå¢æˆ–è‡ªå‡
 333   1      
 334   1        // integrate quaternion rate and normalise  // å››å…ƒç´ çš„å¾®åˆ†æ–¹ç¨‹
 335   1        q0 = q0 + (-q1 * gx - q2 * gy - q3 * gz) * halfT;
 336   1        q1 = q1 + (q0 * gx + q2 * gz - q3 * gy) * halfT;
 337   1        q2 = q2 + (q0 * gy - q1 * gz + q3 * gx) * halfT;
 338   1        q3 = q3 + (q0 * gz + q1 * gy - q2 * gx) * halfT;
 339   1      
 340   1        // normalise quaternion
 341   1        norm = sqrt(q0 * q0 + q1 * q1 + q2 * q2 + q3 * q3);
 342   1        q0 = q0 / norm;
 343   1        q1 = q1 / norm;
 344   1        q2 = q2 / norm;
 345   1        q3 = q3 / norm;
 346   1      
 347   1        Attitude_Angle.Y = asin(-2 * q1 * q3 + 2 * q0 * q2) * 57.3;                 // pitch
 348   1        Attitude_Angle.X = atan2(2 * q2 * q3 + 2 * q0 * q1, -2 * q1 * q1 - 2 * q2 * q2 + 1) * 57.3; // roll
 349   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   5340    ----
   CONSTANT SIZE    =     24    ----
   XDATA SIZE       =    101     143
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
C51 COMPILER V9.01   MPU6050                                                               07/03/2020 15:17:28 PAGE 7   

   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
